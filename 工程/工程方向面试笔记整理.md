[TOC]

参考文献：

https://github.com/wolverinn/Waking-Up/

https://imageslr.github.io/2020/02/26/ipc.html







##### 操作系统

###### 关于进程和线程

- **进程和线程的差别**：
  - 进程是OS 分配资源的基本单位，线程是 CPU 调度的基本单位
  - 线程共享进程的地址空间，也共享进程的很多系统资源；对应的，线程之前通信可以使用共享全局变量进行，很方便
    进程独立拥有的资源只有少量运行中必不可少的资源；对应的，线程切换只需要保存和设置少量寄存器内容
  - 进程拥有独立地址空间，也有独立的 CPU环境；对应的，进程切换的时候需要保存当前进程的整个 CPU 环境(寄存器、进程状态、堆栈中的内容、内存管理信息)，并设置新的 CPU 环境；
  - 多线程程序只要有一个线程崩溃，整个程序就崩溃了；多进程程序中一个进程崩溃并不会对其它进程造成影响，这是独立地址空间使多进程更加健壮

- **同一进程中的线程共享/独占哪些数据：**

  - 共享的：地址空间、代码段、存在堆中的数据(全局变量、静态变量)、打开文件描述符、信号以及信号处理程序
  - 独立拥有：程序计数器等寄存器、栈、错误返回码、信号掩码

- **进程间通信方式有哪些：**

  [各通信方式详细介绍](https://imageslr.github.io/2020/02/26/ipc.html)

  | 方式     | 传输的信息量       | 使用场景       | 关键词                                  |
  | -------- | ------------------ | -------------- | --------------------------------------- |
  | 信号     | 少量               | 任何           | 硬件来源、软件来源 / 信号队列           |
  | 管道     | 大量               | 亲缘进程间     | 内存 / 单向流动 / 内核缓冲区 / 循环队列 |
  | 命名管道 | 大量               | 任何           | 磁盘文件 / 访问权限                     |
  | 信号量   | N                  | 任何           | 互斥同步 / 原子性 / P 减 V 增           |
  | 共享内存 | 大量               | 多个进程       | 内存映射 / 简单快速 / 存在并发问题      |
  | 消息队列 | 比信号多，但有限制 | 任何           | 有格式 / 按消息类型过滤                 |
  | 套接字   | 大量               | 不同主机的进程 | 读缓存区 / 写缓冲区                     |

- 并发、并行、异步的区别？

  - 并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；
  - 并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的
  - 异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事

- 线程同步方式

  - **事件**：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒**一个**等待中的线程，然后自动恢复为未激发状态。
- **临界区**：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。相比于信号量，临界区速度快、节省资源
  
- 进程同步问题
进程的同步是目的，而进程间通信是实现进程同步的手段-》信号量/管程
  
- 生产者-消费者问题
  
    > 问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据
    
    ```C
    // 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量
    semaphore full = 0, empty = n, mutex = 1;
    // 生产者进程
    void producer(){
    	do{
       	  P(empty);
    	  P(mutex);
         // 生产者进行生产
       	  V(mutex);
       	  V(full);
     	} while(1);
    }
    void consumer(){
    	do{
    	  P(full);
    	  P(mutex);
        	// 消费者进行消费
    	  V(mutex);
    	  V(empty);
     	} while(1);
    }
    ```
    
  - 哲学家就餐问题
  
    > 问题描述：有五位哲学家围绕着餐桌坐，每一位哲学家要么思考，要么吃饭。为了吃饭，哲学家必须拿起两双筷子（分别放于左右两端）不幸的是，筷子的数量和哲学家相等，所以每只筷子必须由两位哲学家共享。
  
      ```C
      #define N 5  // number of philosopher
      #define LEFT (i + N - 1)%N // number of i's left neighbors
      #define RIGHT (i + 1)%N // number of i's right neighbors
      #define THINKING 0
      #define HUNGRY 1
      #define EATING 2
      typedef int semaphore;
      int state[N]; // array to keep track of everyone's state
      semaphore mutex = 1; // mutual exclusion of critical region
      semaphore s[N]; 
      
      void philosopher(int i) {
      	while (TRUE) {
      		think();
      		take_forks(i);
      		eat();
      		put_forks(i);
      	}
      }
      
      void take_forks(int i) {
      	down(&mutex); // enter critical region
      	state[i] = HUNGRY; // record that i is hungry
      	test_forks(i); // try to acquire two forks
      	up(&mutex); // exit critical region
      	down(&s[i]); // block if forks are not acquired
      }
      
      void put_forks(int i) {
      	down(&mutex); // enter critical region
      	state[i] = THINKING; // record that has finished eating
      	test_forks(LEFT); // see if left neighbor can now eat
      	test_forks(RIGHT); // see if right neighbor can now eat
      	up(&mutex); // exit critical region
      }
      
      void test_forks(int i) {
      	if (state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] != EATING) {
      		state[i] = EATING;
      		up(&s[i]);
      	}
      }
      ```
  
- 补充
  - 进程应包含程序代码、程序数据、PC、寄存 器、堆、栈、系统资源
    用户级上下文：用户进程的程序块、数据块和用户堆栈组成的地址空间；
    系统级上下文：进程标识信息、现场信息、控制信息、系统堆栈组成的地址空间 ；
    寄存器上下文：PSW，PC，控制寄存器，通用寄存器，用户指针
  - python的多线程是假的多线程，因为python解释器给每个进程按了一个全局解释器锁GIL，一个线程只有拿到了GIL才能执行，因此不管有几个核，由于GIL只有一个，能被执行的线程也就只有一个。为了解决这个问题，我们可以把计算密集型任务用C编写，把.so链接库内容加载到python中，因为在执行C代码的时候，GIL是会被释放的

###### 内存管理

- **虚拟内存的优势**
  
  - 虚拟内存：每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。
  - 为用户提供一个比物理内存容量大得多的可寻址的逻辑地址空间
  - 程序、数据、堆栈大小可以超过内存大小，操作系统将当前使用部分留在内存，把其他部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换
  - 可以提供有效的地址保护：进程拥有独立的地址空间，管理起来更加方便
  - 使用虚拟页式存储管理系统，利用MMU成逻辑地址到物理地址的转换功能，利用块表TLB加速转化过程
  
- **分页和分段有什么区别？**

  - 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻；
  - 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻；
  - 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。

  区别：

  - 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间；
  - 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定；
  - 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）；
  - 分段便于信息的保护和共享；分页的共享受到限制；
  - 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）

- 死锁
  - 死锁的四个条件：互斥、占有且等待、不可抢占、环路等待
  - 死锁预防：破坏死锁的四个条件之一
  - 死锁避免：银行家算法：要求每个进程预先指定完成工作所需的最大资源数量，这样就可以利用不断循环，判断当前剩余资源够不够完成所有任务；不过不够拒绝分配
  - 死锁解除：抢占；回滚；杀死进程

  

- 其他：中断与异常

  - 中断：是随机发生的、可恢复的、由硬件自动完成的。中断的引入主要是为了支持CPU和设备之间的并行操作，实现多机联系和实时控制外部事件。e.g I/O中断、时钟中断
  - 异常：其引入是为了表示CPU执行指令时本身出现的错误。e.g 断点、段错误、溢出、系统调用
  - 基本工作机制：设备发送信号(修改中断寄存器)-》根据中断向量表查得中断描述符-》保存现场至对应的



##### 计算机网络

- **TCP三次握手如何实现？为什么是三次握手？**
  - 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。

    第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

  - 四次浪费资源，两次可能会形成死锁：如果发出syn+ack包没有被客户端接收到，客户端会一直等待syn+ack包而忽略掉数据包，而服务器会一直发送被忽略掉的数据包。

- **什么是四次挥手？**

  - 四次挥手：TCP是全双工模式，
    1. 客户端发送FIN给服务器，表示自己数据发完了；但这个时候客户端还是可以接受来服务器的数据
    2. 服务器发送ACK给客户端，表示它已经知道客户端没有数据发送了
    3. 在服务器把数据都发完了之后，发送FIN给客户端
    4. 客户端发送ACK给服务器，等到time_wait 时长(2个 MSL)之后才真正断开。这个等待是防止最后一个ACK没被接收。
       MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
    5. 过多的time_wait可以用负载均衡来解决

- **TCP 如何实现流量控制？**
  
  - 发送方：提取数据填入发送窗口，发送每个分组的副本；收到确认之后丢弃副本，发送下一个。发送窗口初始大小在三次握手的时候确定，之后动态调整。
  - 接收方：留一个接受窗口。当乱序片段全部到达后，组合成一个完整分组，并返回一个确认给发送方；如果没有全部到达，一段时间后丢弃已经到达的
  
- **TCP 如何实现拥塞控制**
  
  ![拥塞控制](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191129153624025_28293.png)
  
  - 慢启动：一开始拥塞窗口大小从1开始指数增加，到达慢启动阈值后线性增加。发送端根据拥塞窗口和接收窗口大小决定数据包大小。
- 拥塞避免：发生丢包，将慢启动阈值变成当前大小的一半，拥塞窗口设为1重新开始慢启动。
  - 快速重传：收到乱序报文发送重复确认。收到三个重复确认就立即重复传递。
  - 快速恢复：发生快速重传之后，慢启动阈值减半，但是拥塞窗口设置为阈值直接开始线性增加。
  
- **TCP 如何保证传输可靠性**

  - 数据包校验
  - 对失序数据包重新排序（TCP报文具有序列号）
  - 丢弃重复数据
  - 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；
  - 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；
  - 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出

- **HTTP**

- 报文：
  - 请求报文：请求行(方法+URL+版本)、请求头部行(key+ value)、空行和请求数据
  - 响应报文：状态行(版本+状态码)、消息头部、空行和响应正文
  - 状态码含义：
    - 1xx：指示信息。表示请求已接收，继续处理。
    - 2xx：成功。表示请求已被成功接收、理解、接受。
    - 3xx：重定向。要完成请求必须进行更进一步的操作。
    - 4xx：客户端错误。请求有语法错误或请求无法实现。
    - 5xx：服务器端错误。服务器未能实现合法的请求。



##### 其他

- **Q：指针和引用的差别**
  - 指针是指向了一个地址，引用则是一个变量的别名

