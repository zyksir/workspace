##### 操统

- **Q: 堆和栈的的差异**
- **Q: 进程和线程的差别**：
  - 线程是CPU任务调度的基本单位，进程是操作系统资源分配的基本单位。
  - 线程是轻量化的进程。进程调度时空开销打大，进程通信代价大，进程并发粒度较粗
  - 进程有自己独立的地址空间；线程有自己独立的栈和程序计数器，共享地址空间中的其他部分，因此需要锁机制来保护共享信息，避免冲突。
  - 新进程会被分配内存空间，线程不会。
  - 进程是应用程序的启动实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。
  - 线程从属于进程，是程序的实际执行者，一个进程至少包含一个主线程，也可以有更多的子线程，线程拥有自己的栈空间。
- **Q: 简述虚拟内存的优势**
  - 为用户提供一个比物理内存容量大得多的可寻址的逻辑地址空间
  - 程序、数据、堆栈大小可以超过内存大小，操作系统将当前使用部分留在内存，把其他部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换
  - 可以提供有效的地址保护：进程拥有独立的地址空间，管理起来更加方便
  - 使用虚拟页式存储管理系统，利用MMU成逻辑地址到物理地址的转换功能，利用块表TLB加速转化过程
- 进程：
  - 创建步骤：1. 分配进程控制块 2. 初始化机器寄存器 3. 初始化页表 4. 将程序代码从磁盘中读进内存 5. 将处理器状态设置为“用户态”并设置程序计数器
  - 进程应包含程序代码、程序数据、PC、寄存 器、堆、栈、系统资源
  - 关于进程控制：系统会有一个进程控制块PCB，这是一个和进程一一对应的标志，里面会有进程的所有信息，例如进程标识符、进程组关系、寄存器、text&data&stack的指针、打开文件表
  - 进程上下文：
    - 用户级上下文：用户进程的程序块、数据块和用户堆栈组成的地址空间
    - 系统级上下文：进程标识信息、现场信息、控制信息、系统堆栈组成的地址空间 
    - 寄存器上下文：PSW，PC，控制寄存器，通用寄存器，用户指针
  - 进程间同步机制：信号量；管程
  - 进程间通信：信号；管道；FIFO；消息队列；套接字；信号量；共享内存
- 关于线程
  - 由于线程间共享堆，可以用全局变量
  - 这是异步调用的一个方式：
  - python的多线程是假的多线程，因为python解释器给每个进程按了一个全局解释器锁GIL，一个线程只有拿到了GIL才能执行，因此不管有几个核，由于GIL只有一个，能被执行的线程也就只有一个。为了解决这个问题，我们可以把计算密集型任务用C编写，把.so链接库内容加载到python中，因为在执行C代码的时候，GIL是会被释放的
- 中断与异常
  - 中断：是随机发生的、可恢复的、由硬件自动完成的。中断的引入主要是为了支持CPU和设备之间的并行操作，实现多机联系和实时控制外部事件。e.g I/O中断、时钟中断
  - 异常：其引入是为了表示CPU执行指令时本身出现的错误。e.g 断点、段错误、溢出、系统调用
  - 基本工作机制：设备发送信号(修改中断寄存器)-》根据中断向量表查得中断描述符-》保存现场至对应的栈-》根据中断描述符找到中断处理程序入口-》恢复现场
- 同步机制：
  - 生产者、消费者模式的性能问题： 涉及到同步锁、线程状态之间的切换、线程上下文切换
  - 死锁的四个条件：互斥、占有且等待、不可抢占、环路等待
  - 银行家算法：要求每个进程预先指定完成工作所需的最大资源数量，这样就可以利用不断循环，判断当前剩余资源够不够完成所有任务；不过不够拒绝分配
- 内存管理
  - 段页式存储管理方案：使用页式提高内存利用率、使用段氏实现逻辑单元独立性；系统以页为单位进行分配和管理存储

##### 网络

- **TCP三次握手如何实现？为什么是三次握手？**
  - 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态。

    第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

  - 四次浪费资源，两次可能会形成死锁：如果发出syn+ack包没有被客户端接收到，客户端会一直等待syn+ack包而忽略掉数据包，而服务器会一直发送被忽略掉的数据包。

  - 四次挥手：TCP是全双工模式，

    1. 主机1发送FIN给主机2，表示自己数据发完了；但这个时候主机1还是可以接受来主机2的数据
    2. 主机2发送ACK给主机1，表示它已经知道主机1没有数据发送了
    3. 主机2发送FIN给主机1
    4. 主机1发送ACK给主机2，等到time_wait的时长之后才真正断开。这个等待是防止最后一个ACK没被接收
    5. 过多的time_wait可以用负载均衡来解决

- **TCP**

- 滑动窗口机制
  - 发送方：提取数据填入发送窗口，发送每个分组的副本；收到确认之后丢弃副本，发送下一个。发送窗口初始大小在三次握手的时候确定，之后动态调整。
  - 接收方：留一个接受窗口。当乱序片段全部到达后，组合成一个完整分组，并返回一个确认给发送方；如果没有全部到达，一段时间后丢弃已经到达的
- 拥塞控制
  - 慢启动：一开始拥塞窗口大小指数增加，到达慢启动阈值后线性增加。发送端根据拥塞窗口和接收窗口大小决定数据包大小。
  - 拥塞避免：发生丢包，将慢启动阈值变成当前大小的一半，拥塞窗口设为1重新开始慢启动。
  - 快速重传：收到乱序报文发送重复确认。收到三个重复确认就立即重复传递。
  - 快速恢复：发生快速重传之后，慢启动阈值减半，但是拥塞窗口设置为阈值直接开始线性增加。

- **HTTP**
- 报文：
  - 请求报文：请求行(方法+URL+版本)、请求头部行(key+ value)、空行和请求数据
  - 响应报文：状态行(版本+状态码)、消息头部、空行和响应正文
  - 状态码含义：
    - 1xx：指示信息。表示请求已接收，继续处理。
    - 2xx：成功。表示请求已被成功接收、理解、接受。
    - 3xx：重定向。要完成请求必须进行更进一步的操作。
    - 4xx：客户端错误。请求有语法错误或请求无法实现。
    - 5xx：服务器端错误。服务器未能实现合法的请求。

##### 体系



##### 其他

- **Q：指针和引用的差别**
  - 指针是指向了一个地址，引用则是一个变量的别名

